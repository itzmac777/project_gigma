<div class="flex">
    <div class="flex bottom-5 rounded left-[35vw] bg-white bottom-0 absolute gap-3 flex-1 p-3">
        <div id="move-btn" class="border">move</div>
        <div id="rect-btn" class="border">rect</div>r
    </div>
    <div class="bg-gray-300 flex flex-5 min-h-[100vh] overflow-hidden">
        <canvas class="bg-white" data-room-name=<%= roomName %> data-state="move" id="canvas"></canvas>
    </div>
</div>
<script src="/socket.io/socket.io.js"></script>
<script>
    const moveBtn = document.getElementById("move-btn")
    const rectBtn = document.getElementById("rect-btn")
    const socket = io()
    const canvas = document.getElementById('canvas');
    const roomName = canvas.dataset.roomName;

    moveBtn.addEventListener('click', e=> {
        canvas.dataset.state = 'move'
    })

    
    rectBtn.addEventListener('click', e=> {
        canvas.dataset.state = 'rect'
    })

    const ctx = canvas.getContext("2d")

    let width = window.innerWidth
    let height = window.innerHeight;
    canvas.style.width = width + "px"
    canvas.style.height = height + "px"

    let scale = window.devicePixelRatio
    canvas.width = width * scale
    canvas.height = height * scale
    ctx.scale(scale, scale)
    let rect = canvas.getBoundingClientRect()


    let rectData = [{
        x: 10,
        y: 10,
        width: 40,
        height: 20
    }, {
        x: 100,
        y: 50,
        width: 40,
        height: 20
    }, {
        x: 300,
        y: 200,
        width: 40,
        height: 20
    },
    ]

    let currRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    }

    let moveElem = false;
    let selectedRect = -1;
    let clickedCorner = [false, false, false, false]
    drawCanvasData()

    socket.emit('join-room', roomName);
    socket.on('room-state', msg=> {
        console.log(msg)
    });

    document.addEventListener("mousemove", e=> {
        socket.emit('mouse-position', {x: e.clientX, y: e.clientY})
    })

    socket.on('rect-data', data=> {
        rectData = data;
        drawCanvasData()
    })
    socket.on('broadcasted-mouse-position', data=> {
        drawMouseOnCanvas(data.cords, data.id)
    })
    socket.on('create-rect', data=> {
        ctx.beginPath()
        ctx.rect(data.x, data.y, data.width, data.height)
        ctx.lineWidth = 1
        ctx.strokeStyle = 'gray'
        ctx.stroke()
    })

    socket.on('push-rect', data=> {
        rectData.push(data)
    })

    socket.on('move-rect', data=> {
        rectData[data.index].x = data.x;
        rectData[data.index].y = data.y
    })

    socket.on("scale-rect", (data)=> {
            rectData[data.index].x = data.x;
            rectData[data.index].y = data.y;
            rectData[data.index].width = data.width;
            rectData[data.index].height = data.height;
        }
    )

    socket.on("delete-rect", index=> {
        rectData.splice(index, 1)
    })

    document.addEventListener("keydown", e=> {
        if(e.code === 'KeyR'){
            canvas.dataset.state = 'rect'
        }
        if(e.code === 'KeyM'){
            canvas.dataset.state = 'move'
        }
        if(e.code === 'Delete'){
            if(selectedRect != -1){
                rectData.splice(selectedRect, 1)
                socket.emit("server-delete-rect", selectedRect)
                selectedRect = -1;
                drawCanvasData()
            }
        }
    })
    window.addEventListener('resize', e=> {
        drawCanvasData()
    })

    document.addEventListener("mousedown", e=> {
        const x = e.clientX - rect.left
        const y = e.clientY - rect.top;
        clickedCorner = isClickedCornerOfRect(x, y, rectData[selectedRect])
        if(canvas.dataset.state == "rect"){
            drawCanvasData()
            currRect = {
                x: x,
                y: y,
                width: 0,
                height: 0
            }
            document.addEventListener("mousemove", createRect)
        }
        if(selectedRect != -1 && isClickedInsideRect(x, y, rectData[selectedRect]) && canvas.dataset.state == 'move' && !clickedCorner.some(val => val == true)){
            moveElem = true;
            currRect = rectData[selectedRect];
            document.addEventListener("mousemove", moveRect)
        }
        if(canvas.dataset.state !== "rect" && selectedRect != -1 && clickedCorner.some(val => val == true)){
            document.addEventListener("mousemove", scaleRect)
        }
    })

    canvas.addEventListener("click", selectRect)


    document.addEventListener("mouseup", e=> {
        if(canvas.dataset.state == "rect"){
            document.removeEventListener("mousemove", createRect)
            rectData.push(currRect)
            socket.emit("server-push-rect", currRect)
        }
        document.removeEventListener("mousemove", moveRect)
        document.removeEventListener('mousemove', scaleRect)
        clickedCorner = [false, false, false, false]
        selectRect = -1
        moveElem = false
    })
    


    function drawMouseOnCanvas(cords, id){
        drawCanvasData()
        ctx.beginPath()
        ctx.lineWidth = 1
        ctx.strokeStyle = 'gray'
        ctx.rect(cords.x, cords.y, 10, 15)
        ctx.rect(cords.x + 4, cords.y + 2, 3, 5)
        ctx.stroke()
        ctx.font = '10px Arial'
        ctx.fillText(id.slice(1, 5), cords.x - 2, cords.y - 3)
    }

    function scaleRect(e){
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const currRect = rectData[selectedRect];
        const minHeightWidth = 20;
        drawCanvasData()
        //top-left
        if(clickedCorner[0] && clickedCorner[3]){
            if(currRect.width + (currRect.x - x) >= minHeightWidth){
                currRect.width += currRect.x - x
                currRect.x = x;
            }
            if(currRect.height + (currRect.y - y) >= minHeightWidth){
                currRect.height += currRect.y - y
                currRect.y = y
            }
        }
        //top-right
        if(clickedCorner[0] && clickedCorner[1]){
            if(x - currRect.x >= minHeightWidth){
                currRect.width = x - currRect.x;
            }
            if(currRect.height + (currRect.y - y) >= minHeightWidth){
                currRect.height += currRect.y - y
                currRect.y = y
            }
        }
        //bottom-right
        if(clickedCorner[2] && clickedCorner[1]){
            if(x - currRect.x >= minHeightWidth){
                currRect.width = x - currRect.x
            }
            if(y - currRect.y >= minHeightWidth){
                currRect.height = y - currRect.y
            }
        }
        // bottom-left
        if(clickedCorner[2] && clickedCorner[3]){
            if(currRect.width + (currRect.x - x) >= minHeightWidth){
                currRect.width += currRect.x - x
                currRect.x = x
            }
            if(y - currRect.y >= minHeightWidth){
                currRect.height = y - currRect.y;
            }
        }
        socket.emit("server-scale-rect", {
            index: selectedRect,
            x: currRect.x,
            y: currRect.y,
            width: currRect.width,
            height: currRect.height
        })
    }

    function isClickedCornerOfRect(x, y, rect){
        const radiusOfClick = 0.1;
        if(!rect) return;
        //Clockwise from top (ex. top-left -> top-right)
        if(x >= rect.x && x <= rect.x + rect.width * radiusOfClick && y >= rect.y && y <= rect.y + rect.height * radiusOfClick){
            return [true, false, false, true]   
        } else if(x <= rect.x + rect.width && x >= rect.x + rect.width - rect.width * radiusOfClick && y >= rect.y && y <= rect.y + rect.height * radiusOfClick){
            return [true, true, false, false]    
        } else if(x <= rect.x + rect.width && x >= rect.x + rect.width - rect.width * radiusOfClick && y <= rect.y + rect.height && y >= rect.y + rect.height - rect.height * radiusOfClick){
            return [false, true, true, false]      
        } else if(x >= rect.x && x <= rect.x + rect.width * radiusOfClick && y <= rect.y + rect.height && y >= rect.y + rect.height - rect.height * radiusOfClick){
            return [false, false, true, true]
        } else{
            return [false, false, false, false]
        }
    }

    function selectRect(e){
        const x = e.clientX - rect.left
        const y = e.clientY - rect.top
        drawCanvasData()
        for(let i = 0; i < rectData.length; i++){
            if(isClickedInsideRect(x, y, rectData[i])){
                drawOutline(rectData[i])
                selectedRect = i;
                break;
            } else{
                selectedRect = -1;
            }
        }
    }

    function isClickedInsideRect(x, y, rect){
        return (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height)
    }

    function drawOutline(rect){
        ctx.beginPath()
        ctx.lineWidth = 1
        ctx.strokeStyle = 'blue'
        ctx.rect(rect.x, rect.y, rect.width, rect.height)
        ctx.stroke()
    }

    function createRect(e){
        drawCanvasData()
        ctx.beginPath()
        ctx.rect(currRect.x, currRect.y, e.clientX - currRect.x, e.clientY - currRect.y)
        ctx.lineWidth = 1
        ctx.strokeStyle = 'gray'
        ctx.stroke()
        socket.emit("server-create-rect", {
            x: currRect.x,
            y: currRect.y,
            width: e.clientX - currRect.x,
            height: e.clientY - currRect.y
        })
        currRect.width = e.clientX - currRect.x; 
        currRect.height = e.clientY - currRect.y
    }

    function moveRect(e){
        drawCanvasData()
        const x = e.clientX - rect.left
        const y = e.clientY - rect.top;
        currRect.x = x - currRect.width / 2;
        currRect.y = y - currRect.height / 2;
        socket.emit("server-move-rect", {
            index: selectedRect,
            x: x - currRect.width / 2,
            y: y - currRect.height / 2
        })
    }

    function drawCanvasData(){
        ctx.clearRect(0,0, canvas.width, canvas.height)
        rectData.forEach(rect=> {
            ctx.beginPath()
            ctx.rect(rect.x, rect.y, rect.width, rect.height)
            ctx.lineWidth = 1
            ctx.strokeStyle = 'black'
            ctx.stroke()
        })
    }
</script>